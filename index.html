<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Monolith Pathtracer</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-text-color: #e0e0e0;
            --secondary-text-color: #aaa;
            --input-bg-color: #2a2a2a;
            --border-color: #333;
            --accent-color: #d93025;
            --accent-hover-color: #e84c4c;
            --button-secondary-bg: #28a745;
            --button-secondary-hover: #218838;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            -webkit-user-select: none; -ms-user-select: none; user-select: none;
        }

        input, textarea, select { -webkit-user-select: text; -ms-user-select: text; user-select: text; }

        #container {
            text-align: center;
            background-color: var(--surface-color);
            padding: 2rem;
            border-radius: 12px;
            width: 100%;
            max-width: 1100px;
        }

        h1 {
            color: #ffffff;
            margin-top: 0;
            font-size: 2.5em;
        }

        p {
            max-width: 650px;
            margin: 0.5rem auto 1rem auto;
            color: var(--secondary-text-color);
        }

        canvas {
            background-color: #000;
            border-radius: 8px;
            margin-top: 1rem;
            width: 100%;
            height: auto;
            border: 1px solid var(--border-color);
        }

        #controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .control-fieldset {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            flex: 1;
            min-width: 300px;
            max-width: 500px;
        }

        .control-fieldset legend {
            padding: 0 0.5em;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            text-align: left;
            margin-bottom: 1.2rem;
			transition: opacity 0.3s ease;
        }
        
        .control-group:last-child { margin-bottom: 0; }

        .control-group label {
            margin-bottom: 0.5rem;
            font-size: 1.1em;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 10px;
            font-size: 1.1em;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg-color);
            color: var(--primary-text-color);
            box-sizing: border-box;
        }
        
        .inline-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .inline-group label { margin-bottom: 0; }
        .inline-group input[type="checkbox"] { width: auto; }

        #custom-samples-group { display: none; margin-top: 10px;}
        #customSamplesInput { width: 100px; }
        .thread-info-text { color: #888; font-size: 0.8em; margin-bottom: 4px; }

        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 2rem;
        }

        .benchmark-button {
            padding: 14px 28px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .benchmark-button:disabled { background-color: #555; cursor: not-allowed; }
        .start-button { background-color: var(--accent-color); color: white; }
        .start-button:not(:disabled):hover { background-color: var(--accent-hover-color); }
        #stopButton { background-color: #6c757d; color: white; }
        #stopButton:not(:disabled) { background-color: var(--button-secondary-bg); }
        #stopButton:not(:disabled):hover { background-color: var(--button-secondary-hover); }

        #results {
            margin-top: 2rem;
            background-color: var(--input-bg-color);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            display: inline-block;
            min-width: 350px;
        }
        #results p { margin: 0.5rem 0; font-size: 1.2em; text-align: left; color: #fff; }
        #results strong { display: inline-block; width: 200px; }

        #reset-container { margin-top: 1.5rem; }
        #resetButton { background-color: #007bff; color: white; font-size: 1em; padding: 10px 20px; }
        #resetButton:hover { background-color: #0069d9; }

        #progressBar { width: 100%; height: 28px; background-color: #333; border-radius: 14px; margin-top: 1.5rem; overflow: hidden; display: none; position: relative; }
        #progressFill { width: 0%; height: 100%; background-color: var(--accent-color); transition: width 0.1s linear; }
        #progressText { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; text-shadow: 1px 1px 2px black; }
        
        #disclaimer { margin-top: 1rem; color: #888; font-size: 0.9em; font-style: italic; }

        @media (max-width: 768px) {
            body { padding: 0.5rem; }
            #container { padding: 1rem; }
            h1 { font-size: 2em; }
            .control-fieldset { min-width: 100%; }
        }
.master-preset-container {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    margin-top: 1rem;
}
#masterPresetSelector {
    padding: 10px;
    font-size: 1.1em;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg-color);
    color: var(--primary-text-color);
}

.control-group:has(#noiseThresholdInput:disabled) {
    opacity: 0.5;
    pointer-events: none;
}

    </style>
</head>
<body>
    <div id="container">
        <h1>Monolith Pathtracer</h1>
        <p>A CPU path tracing utility.</p>

        <canvas id="renderCanvas" width="1600" height="900"></canvas>
        <div id="progressBar"> <div id="progressFill"></div> <div id="progressText"></div> </div>

   

        <div id="controls-container">
          
            <fieldset class="control-fieldset">
                <legend>Scene & Performance</legend>
                <div class="control-group">
                    <label for="sceneSelector">Scene:</label>
                    <select id="sceneSelector">
					 <option value="gaussv2" selected>Caustic Hell v2 (new, fast, extremely demanding, needs >256 ray bounces, WASM)</option>
                        <option value="gauss">Caustic Hell (old, slow, needs >256 ray bounces, WASM)</option>
						<option value="simple">Staircase (fastest, more advanced, WASM)</option>
                        <option value="v3">Spheres v3 (slow, realistic, WASM)</option>
                        <option value="v2">Spheres v2 (slow, unrealistic, WASM)</option>
                        <option value="old">Spheres v1 (slowest, <50 ray bounces recommended, WASM)</option>
                        <option value="javascript">Spheres JS (inefficient, JavaScript)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="threadInput">Threads:</label>
                   
                    <input type="number" id="threadInput" title="Number of threads to run." min="1">
                </div>
                <div class="control-group">
                    <label for="resolutionInput">Resolution:</label>
                    <input type="text" id="resolutionInput" placeholder="1600x900">
                </div>
            </fieldset>

            
            <fieldset class="control-fieldset">
                <legend>Render Quality</legend>
                <div class="control-group">
                    <label for="benchmarkSelector">Samples Preset:</label>
                    <select id="benchmarkSelector">
                        <option value="16">Ultra Light (16 Samples)</option>
                        <option value="64">Light (64 Samples)</option>
                        <option value="256" selected>Medium (256 Samples)</option>
                        <option value="512">Heavy (512 Samples)</option>
                        <option value="1024">Extreme (1024 Samples)</option>
                        <option value="custom">Custom</option>
                    </select>
                    <div id="custom-samples-group" class="inline-group">
                        <label for="customSamplesInput">Custom Samples:</label>
                        <input type="number" id="customSamplesInput" value="256" min="1">
                    </div>
                </div>
				
                <div class="control-group">
                    <label for="maxDepthInput">Max Ray Bounces:</label>
                    <input type="number" id="maxDepthInput" title="Maximum number of ray bounces." value="512" min="1">
                </div>
                <div class="control-group">
                    <label for="tileSizeInput">Render Tile Size (px):</label>
                    <input type="number" id="tileSizeInput" title="Size of the rendering chunks in pixels." value="64" min="16" step="16">
                </div>
				
<div class="control-group">
    <label for="noiseThresholdInput">Noise Threshold (higher = faster, <0.0001 = no adaptive sampling & max quality, recommended between 0.04 and 0.12):</label>
    <input type="number" id="noiseThresholdInput" value="0.11" step="0.01" min="0.000001" title="Lower is cleaner but slower. The sweet spot is often between 0.04 and 0.12.">
</div>
                <div class="control-group">
                    <div class="inline-group">
                      <input type="checkbox" id="denoiser-toggle">
                      <label for="denoiser-toggle">Denoiser</label>
                    </div>
                    <div class="inline-group">
                      <input type="checkbox" id="debug-toggle">
                      <label for="debug-toggle">Variance Mapping (for debugging)</label>
                    </div>
					
                </div>
            </fieldset>
			<div class="master-preset-container">
                <label for="masterPresetSelector"><strong>Benchmark Preset:</strong></label>
                <select id="masterPresetSelector">
                    <option value="SmartphoneFriendly">Smartphone Friendly</option>
                    <option value="LightRendering">Light rendering</option>
                    <option value="Workstation" selected>Workstation</option>
                    <option value="Cinematic">Cinematic</option>
					<option value="Photorealistic">Photorealistic</option>
					<option value="PIAV">Patience Is A Virtue</option>
                </select>
            </div>
        </div>

        <div class="button-group">
            <button id="startSingleButton" class="benchmark-button start-button">Start Single-Threaded</button>
            <button id="startMultiButton" class="benchmark-button start-button">Start Multi-Threaded</button>
            <button id="stopButton" class="benchmark-button" disabled>Stop</button>
        </div>
        
        <div id="results">
            <p><strong>Single-thread time:</strong> <span id="singleThreadTime">-</span></p>
            <p><strong>Multi-thread time:</strong> <span id="multiThreadTime">-</span></p>
        </div>

        <div id="reset-container">
            <button id="resetButton" class="benchmark-button">Reset to default</button>
        </div>
        
        <br><br><h3>Please note:</h3>
		<p id="disclaimer">1. Scene initialization may take a few moments, particularly on tests with a high sample count.</p>
		<p id="disclaimer">2. Javascript scenes are heavily dependent on the browser you're using, don't expect consistent scores across browsers.</p>
    </div>
    <script>
        (function() {
		let batchSize;
            const startSingleButton = document.getElementById('startSingleButton');
            const startMultiButton = document.getElementById('startMultiButton');
            const stopButton = document.getElementById('stopButton');
            const resetButton = document.getElementById('resetButton');
            const threadInput = document.getElementById('threadInput');
            const benchmarkSelector = document.getElementById('benchmarkSelector');
            const canvas = document.getElementById('renderCanvas');
            const ctx = canvas.getContext('2d');
            const singleThreadTimeEl = document.getElementById('singleThreadTime');
            const multiThreadTimeEl = document.getElementById('multiThreadTime');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const customSamplesGroup = document.getElementById('custom-samples-group');
            const customSamplesInput = document.getElementById('customSamplesInput');
            const tileSizeInput = document.getElementById('tileSizeInput');
            const maxDepthInput = document.getElementById('maxDepthInput');
            const resolutionInput = document.getElementById('resolutionInput');
            const sceneSelector = document.getElementById('sceneSelector');
            const denoiserToggle = document.getElementById('denoiser-toggle');
			const debugToggle = document.getElementById('debug-toggle');
            const scenesSupportingDebug = ['simple'];
			const masterPresetSelector = document.getElementById('masterPresetSelector');
			const noiseThresholdInput = document.getElementById('noiseThresholdInput');
			const scenesSupportingAdaptiveSampling = ['simple'];

            let wasmBinaries = {};
			const legacyScenes = ['gauss', 'v3', 'v2', 'old', 'javascript'];
            let activeWorkers = [];
            let isBenchmarkRunning = false;
            const fullPath = self.location.href;
            const basePath = fullPath.substring(0, fullPath.lastIndexOf('/'));
            threadInput.value = navigator.hardwareConcurrency || 4;
             // --- MISSING PIECES FOR UI THROTTLING (NOW INCLUDED) ---
            let pendingFrame = false;
            let lastCompletedTiles = 0;
            let renderWidth = canvas.width, renderHeight = canvas.height;
function updateProgressUI(totalTiles, completedTiles) {
                const progressPercentage = (completedTiles / totalTiles) * 100;
                progressFill.style.width = `${progressPercentage}%`;
                progressText.textContent = `${Math.round(progressPercentage)}%`;
                pendingFrame = false; // Reset the flag to allow the next update
            }
            function checkCustomPreset() { if (benchmarkSelector.value === 'custom') { customSamplesGroup.style.display = 'flex'; } else { customSamplesGroup.style.display = 'none'; } }
            checkCustomPreset();
            benchmarkSelector.addEventListener('change', checkCustomPreset);

            const masterPresets = {
                'SmartphoneFriendly': {
                    resolution: '800x800',
                    samples: 32,
                    maxDepth: 384,
                    tileSize: 32,
					noiseThreshold: 0.21,
                },
                'LightRendering': {
                    resolution: '1280x720',
                    samples: 64,
                    maxDepth: 512,
                    tileSize: 64,
                    noiseThreshold: 0.18,
				},
                'Workstation': {
                    resolution: '1600x900',
                    samples: 128,
                    maxDepth: 512,
                    tileSize: 64,
                    noiseThreshold: 0.14,
				},
                'Cinematic': {
                    resolution: '2560x1440',
                    samples: 512,
                    maxDepth: 512,
                    tileSize: 64,
                    noiseThreshold: 0.10,
				},
				 'Photorealistic': {
                    resolution: '2560x1440',
                    samples: 1024,
                    maxDepth: 512,
                    tileSize: 64,
                    noiseThreshold: 0.0001,
				},
				 'PIAV': {
                    resolution: '3840x2160',
                    samples: 2048,
                    maxDepth: 512,
                    tileSize: 64,
                    noiseThreshold: 0.0001,
				},
				
            };

            function applyMasterPreset(presetName) {
                const preset = masterPresets[presetName];
                if (!preset) return;

                resolutionInput.value = preset.resolution;
                maxDepthInput.value = preset.maxDepth;
                tileSizeInput.value = preset.tileSize;
				noiseThresholdInput.value = preset.noiseThreshold;

                const sampleValueStr = preset.samples.toString();
                const isPresetSample = [...benchmarkSelector.options].some(opt => opt.value === sampleValueStr);

                if (isPresetSample) {
                    benchmarkSelector.value = sampleValueStr;
                } else {
                    benchmarkSelector.value = 'custom';
                    customSamplesInput.value = preset.samples;
                }
                
                checkCustomPreset();
            }

            masterPresetSelector.addEventListener('change', (e) => {
                applyMasterPreset(e.target.value);
            });
            function updateUIForScene() {
                const selectedScene = sceneSelector.value;
                const isWasmScene = selectedScene !== 'javascript';
                const supportsDenoiser = (selectedScene === "javascript" || selectedScene === 'v2' || selectedScene === 'gauss' || selectedScene === 'v3' || selectedScene === "simple");
                denoiserToggle.disabled = !supportsDenoiser;
                if (!supportsDenoiser) {
                    denoiserToggle.checked = false;
                }
    const supportsAdaptive = scenesSupportingAdaptiveSampling.includes(selectedScene);
    

    noiseThresholdInput.disabled = !supportsAdaptive;

    const supportsDebug = scenesSupportingDebug.includes(selectedScene);
    debugToggle.disabled = !supportsDebug;
    if (!supportsDebug) {
        debugToggle.checked = false;
    }
            }
            sceneSelector.addEventListener('change', updateUIForScene);
            updateUIForScene(); 

            function parseAndUpdateResolution() {
                const defaultWidth = 1600;
    const defaultHeight = 900;
    const resValue = resolutionInput.value.trim();

    lastResolutionValue = resValue;

                if (!resValue) {
                    renderWidth = defaultWidth;
                    renderHeight = defaultHeight;
                } else {
                    const parts = resValue.toLowerCase().split('x');
                    if (parts.length !== 2) {
                        renderWidth = defaultWidth;
                        renderHeight = defaultHeight;
                        resolutionInput.value = `${defaultWidth}x${defaultHeight}`;
                        console.warn("Invalid resolution format. Falling back to 1600x900.");
                    } else {
                        const width = parseInt(parts[0], 10);
                        const height = parseInt(parts[1], 10);

                        if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
                            renderWidth = defaultWidth;
                            renderHeight = defaultHeight;
                            resolutionInput.value = `${defaultWidth}x${defaultHeight}`;
                            console.warn("Invalid resolution numbers. Falling back to 1600x900.");
                        } else {
                            renderWidth = width;
                            renderHeight = height;
                        }
                    }
                }
                canvas.width = renderWidth;
                canvas.height = renderHeight;
            }

            async function prepareWasm(benchmarkName) {
    if (benchmarkName === 'javascript' || wasmBinaries[benchmarkName]) return;

    try {
        const wasmResponse = await fetch(`${basePath}/raytracer_${benchmarkName}.wasm`);
        if (!wasmResponse.ok) throw new Error(`Failed to fetch WASM file: ${wasmResponse.statusText}`);

        if (legacyScenes.includes(benchmarkName)) {
       
            console.log(`Using ArrayBuffer loading for old scene: ${benchmarkName}`);
            wasmBinaries[benchmarkName] = await wasmResponse.arrayBuffer();
        } else {
          
            console.log(`Using compileStreaming for modern scene: ${benchmarkName}`);
            wasmBinaries[benchmarkName] = await WebAssembly.compileStreaming(wasmResponse);
        }

    } catch (error) {
        console.error("WASM Preparation Error:", error);
        progressText.textContent = `Error: Could not load scene files.`;
        throw error;
    }
}
            
            async function runBenchmark(numThreads, samplesPerPixel, TILE_SIZE, MAX_DEPTH, benchmarkName, useDenoiser, debugMode, noiseThreshold) {
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height); progressFill.style.width = '0%';
                const tiles = [];
                for (let y = 0; y < renderHeight; y += TILE_SIZE) { 
                    for (let x = 0; x < renderWidth; x += TILE_SIZE) { 
                        tiles.push({ x, y, size: TILE_SIZE }); 
                    } 
                }
                let workQueue = [...tiles];
				const totalTiles = tiles.length;
				// --- DYNAMIC BATCH SIZE CALCULATION ---
batchSize = Math.ceil(totalTiles / numThreads);
console.log(`Static Partitioning Enabled: ${totalTiles} tiles, ${numThreads} threads. Assigning one batch of up to ${batchSize} tiles per worker.`);
// --- END OF CALCULATION ---
				let completedTiles = 0;
                progressText.textContent = `Creating ${numThreads} thread(s)...`;
                let startTime; let timerStarted = false; let hasFailed = false;

                const isJsScene = benchmarkName === 'javascript';

                return new Promise((resolve, reject) => {
                    let initializedWorkers = 0;
                    const cleanupAndFail = (errorMessage) => { if (hasFailed) return; hasFailed = true; isBenchmarkRunning = false; console.error(errorMessage); progressText.textContent = `Error: ${errorMessage}`; activeWorkers.forEach(w => { if (w && w.worker) w.worker.terminate(); }); activeWorkers = []; reject(new Error(errorMessage)); };
                    
                    function onWorkerMessage(workerObj, e) {
                        if (!isBenchmarkRunning || hasFailed) return;
                        const msg = e.data;
                        switch (msg.type) {
                            case 'ready': 
                                workerObj.isReady = true;
                                initializedWorkers++;
                                progressText.textContent = `Initializing ${initializedWorkers}/${numThreads} thread(s)...`;
                                if (initializedWorkers === numThreads) {
                                    progressText.textContent = `All threads ready. Starting...`;
									if (!timerStarted) {
                    startTime = performance.now();
                    timerStarted = true;
                }
                                    activeWorkers.forEach(w => dispatchWork(w));
                                }
                                break;
                             case 'scene-initialized': 
                                workerObj.isReady = true;
                                initializedWorkers++;
                                progressText.textContent = `Initializing scene in ${initializedWorkers}/${numThreads} thread(s)...`;
                                if (initializedWorkers === numThreads) {
                                    progressText.textContent = `All scenes initialized. Starting...`;
									 if (!timerStarted) {
            startTime = performance.now();
            timerStarted = true;
        }
                                    activeWorkers.forEach(w => dispatchWork(w));
                                }
                                break;
                            // INSIDE the onWorkerMessage function from your FIRST code block

case 'result':
    // The timer logic we fixed before should be placed at the 'ready' and 'scene-initialized' cases, not here.
    
    // 1. The message now contains an array called 'results'. Loop through it.
    for (const result of msg.results) {
        const { pixelData, tile } = result;

        // Use the more performant graphics pipeline
        const imageData = new ImageData(new Uint8ClampedArray(pixelData), tile.size, tile.size);
        createImageBitmap(imageData).then(imageBitmap => {
            ctx.drawImage(imageBitmap, tile.x, tile.y);
        });

        completedTiles++;
    }

    // 2. Throttle the progress bar update to happen only once per frame.
    lastCompletedTiles = completedTiles; 
    if (!pendingFrame) { 
        pendingFrame = true;
        // CORRECTED: Pass 'completedTiles' to the function
        requestAnimationFrame(() => updateProgressUI(totalTiles, completedTiles)); 
    }

    // 3. Check for completion and dispatch the next batch.
    if (completedTiles === totalTiles) {
        // This is where you calculate the final time
        const totalTime = (performance.now() - startTime) / 1000;
        activeWorkers.forEach(w => w.worker.terminate());
        activeWorkers = [];
        resolve({ time: totalTime });
    } else {
        dispatchWork(workerObj);
    }
    break;
                            case 'error':
                                cleanupAndFail(`Worker #${workerObj.id} failed: ${msg.error}`);
                                break;
                        }
                    };

                    function dispatchWork(workerObj) {
    // 1. Create an empty batch array.
    const batch = [];

    // 2. Fill the batch with tiles from the queue, up to BATCH_SIZE.
    for (let i = 0; i < batchSize && workQueue.length > 0; i++) {
        batch.push(workQueue.pop());
    }

    // 3. If the batch has tiles, send it to the worker.
    if (batch.length > 0) {
        // We can still provide visual feedback, just for the first tile in the batch.
        const firstTile = batch[0];
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(firstTile.x, firstTile.y, firstTile.size, firstTile.size);
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'white';
        ctx.fillText(workerObj.id, firstTile.x + firstTile.size / 2, firstTile.y + firstTile.size / 2);

        // 4. Construct the message with a new type 'render-batch' and the array of tiles.
        // We also need to re-read settings here to pass them along.
        const message = {
            type: 'render-batch',
            tiles: batch,
            canvasWidth: renderWidth,
            canvasHeight: renderHeight,
            samplesPerPixel: parseInt(benchmarkSelector.value === 'custom' ? customSamplesInput.value : benchmarkSelector.value, 10),
            maxDepth: parseInt(maxDepthInput.value, 10) || 512,
            useDenoiser: denoiserToggle.checked,
            debugMode: debugToggle.checked ? 1 : 0,
            noiseThreshold: parseFloat(noiseThresholdInput.value) || 0.11
        };
        workerObj.worker.postMessage(message);
    }
}
                    
                    for (let i = 0; i < numThreads; i++) {
                        try {
                            const worker = new Worker('universal-worker.js');
                            const workerObj = { worker, id: i, isReady: false };
                            worker.onmessage = (e) => onWorkerMessage(workerObj, e);
                            worker.onerror = (e) => cleanupAndFail(`An unexpected error in Worker #${i}: ${e.message}`);
                            activeWorkers.push(workerObj);

                            if (isJsScene) {
                              
                                worker.postMessage({ type: 'init-scene', scene: 'cornell' });
                            } else {
                                const jsUrl = `${basePath}/raytracer_${benchmarkName}.js`;
const wasmModule = wasmBinaries[benchmarkName];
const isLegacy = legacyScenes.includes(benchmarkName);
worker.postMessage({ type: 'init-wasm', wasmModule: wasmModule, jsUrl: jsUrl, isLegacy: isLegacy });
                            }
                        } catch (error) {
                            return cleanupAndFail(`Failed to create Worker #${i}. ${error.message}`);
                        }
                    }
                });
            }

            async function startBenchmark(numThreads, targetTimeEl) {
                isBenchmarkRunning = true;
                startSingleButton.disabled = true; startMultiButton.disabled = true; stopButton.disabled = false;
                targetTimeEl.textContent = '...'; progressBar.style.display = 'block'; progressText.textContent = '';
                
                parseAndUpdateResolution();

                try {
                    let samplesPerPixel = parseInt(benchmarkSelector.value === 'custom' ? customSamplesInput.value : benchmarkSelector.value, 10);
                    if (isNaN(samplesPerPixel) || samplesPerPixel <= 0) throw new Error("Please enter a valid number of samples.");
                    const TILE_SIZE = parseInt(tileSizeInput.value, 10) || 64;
                    const MAX_DEPTH = parseInt(maxDepthInput.value, 10) || 512;
                    const benchmarkName = sceneSelector.value;
                    const useDenoiser = denoiserToggle.checked;
                    const debugMode = debugToggle.checked ? 1 : 0;
				
        const noiseThreshold = parseFloat(noiseThresholdInput.value) || 0.11;
		
                    await prepareWasm(benchmarkName);
                    const result = await runBenchmark(numThreads, samplesPerPixel, TILE_SIZE, MAX_DEPTH, benchmarkName, useDenoiser, debugMode, noiseThreshold);
                    targetTimeEl.textContent = `${result.time.toFixed(3)}s`;
                    progressText.textContent = 'Done!';
                } catch (error) {
                   console.error("Benchmark failed:", error.message);
                   progressText.textContent = `Error: ${error.message}`;
                } finally {
                    if (isBenchmarkRunning) {
                        isBenchmarkRunning = false;
                        startSingleButton.disabled = false; startMultiButton.disabled = false; stopButton.disabled = true;
                    }
                }
            }

            stopButton.addEventListener('click', () => {
                if (!isBenchmarkRunning) return;
                console.log("Stopping benchmark..."); isBenchmarkRunning = false;
                activeWorkers.forEach(w => w.worker.terminate()); activeWorkers = [];
                progressText.textContent = 'Benchmark Stopped.';
                singleThreadTimeEl.textContent = '-'; multiThreadTimeEl.textContent = '-';
                startSingleButton.disabled = false; startMultiButton.disabled = false; stopButton.disabled = true;
            });
            
            resetButton.addEventListener('click', () => {
                console.log("Resetting settings to default.");
                sceneSelector.value = "gauss";
                benchmarkSelector.value = "256"; customSamplesInput.value = "128";
                threadInput.value = navigator.hardwareConcurrency || 4;
                tileSizeInput.value = "64"; maxDepthInput.value = "512";
                resolutionInput.value = "";
                denoiserToggle.checked = false;
				 debugToggle.checked = false;
				 noiseThresholdInput.value = "0.11";
                checkCustomPreset();
                updateUIForScene();
            });

            startSingleButton.addEventListener('click', () => { startBenchmark(1, singleThreadTimeEl); });
            startMultiButton.addEventListener('click', () => { let numThreads = parseInt(threadInput.value, 10); if (isNaN(numThreads) || numThreads <= 0) { numThreads = navigator.hardwareConcurrency || 4; threadInput.value = numThreads; } startBenchmark(numThreads, multiThreadTimeEl); });

        })();
    </script>
</body>
</html>
