<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Monolith CPU Benchmark (WASM) â€” Definitive Edition</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background-color: #121212; 
            color: #e0e0e0; 
            margin: 0; 
            padding: 1rem; 
            box-sizing: border-box; 
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        input, textarea, select {
            -webkit-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        #container { text-align: center; background-color: #1e1e1e; padding: 2rem; border-radius: 12px; width: 100%; max-width: 1100px; }
        h1 { color: #ffffff; margin-top: 0; font-size: 2.5em; }
        p { max-width: 650px; margin: 0.5rem auto 1rem auto; color: #aaa; }
        canvas { background-color: #000; border-radius: 8px; margin-top: 1rem; width: 100%; height: auto; border: 1px solid #333; }
        #controls { margin: 1.5rem 0; }
        .input-group { display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 1rem; flex-wrap: wrap; }
        .thread-info-text { color: #888; opacity: 0.7; font-size: 0.9em; font-style: italic; margin-right: 15px; }
        .input-group label { font-size: 1.1em; }
        #threadInput, #benchmarkSelector { padding: 10px; font-size: 1.1em; border-radius: 8px; border: 1px solid #333; background-color: #2a2a2a; color: #e0e0e0; }
        #threadInput { width: 80px; text-align: center; }
        .button-group { display: flex; justify-content: center; gap: 1rem; margin-top: 1rem; }
        .benchmark-button { padding: 14px 28px; font-size: 1.1em; font-weight: bold; cursor: pointer; border: none; border-radius: 8px; background-color: #d93025; color: white; transition: background-color 0.2s ease; }
        .benchmark-button:disabled { background-color: #555; cursor: not-allowed; }
        .benchmark-button:not(:disabled):hover { background-color: #e84c4c; }
        #results { margin-top: 1rem; background-color: #2a2a2a; padding: 1rem 1.5rem; border-radius: 8px; display: inline-block; min-width: 350px; }
        #results p { margin: 0.5rem 0; font-size: 1.2em; text-align: left; color: #fff; }
        #results strong { display: inline-block; width: 200px; }
        #progressBar { width: 100%; height: 28px; background-color: #333; border-radius: 14px; margin-top: 1.5rem; overflow: hidden; display: none; position: relative; }
        #progressFill { width: 0%; height: 100%; background-color: #d93025; transition: width 0.1s linear; }
        #progressText { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; text-shadow: 1px 1px 2px black; }
    </style>
</head>
<body>
    <div id="container">
        <h1>Monolith CPU Benchmark (Pathtracer)</h1>
        <p>A path tracing benchmark with extreme geometric complexity to test your CPU's floating-point performance.</p>
        <canvas id="renderCanvas" width="1600" height="900"></canvas>
        <div id="progressBar">
            <div id="progressFill"></div>
            <div id="progressText"></div>
        </div>
        <div id="controls">
            <div class="input-group">
                <label for="benchmarkSelector">Benchmark Preset:</label>
                <select id="benchmarkSelector">
                    <option value="64">Light (64 Samples)</option>
                    <option value="256" selected>Medium (256 Samples)</option>
                    <option value="512">Heavy (512 Samples)</option>
                </select>
            </div>
            <div class="input-group">
                <span class="thread-info-text">Wrong thread count? Change it manually.</span>
                <label for="threadInput">Threads:</label>
                <input type="number" id="threadInput" title="Enter the number of threads for the multi-threaded test." min="1">
            </div>
            <div class="button-group">
                <button id="startSingleButton" class="benchmark-button">Start Single-Threaded</button>
                <button id="startMultiButton" class="benchmark-button">Start Multi-Threaded</button>
            </div>
        </div>
        <div id="results">
            <p><strong>Single-thread Time:</strong> <span id="singleThreadTime">-</span></p>
            <p><strong>Multi-thread Time:</strong> <span id="multiThreadTime">-</span></p>
        </div>
    </div>

    <script id="worker-script" type="text/worker">
        var Module = null;
        var wasmInstance = null;
        var renderTile = null;
        var freeFunc = null;

        function getHeapU8(mod) {
            if (!mod) { if (typeof HEAPU8 !== 'undefined') return HEAPU8; return null; }
            if (mod.HEAPU8) return mod.HEAPU8;
            if (mod.asm && mod.asm.HEAPU8) return mod.asm.HEAPU8;
            if (typeof HEAPU8 !== 'undefined') return HEAPU8;
            return null;
        }

        function onModuleReady(m) {
            wasmInstance = m || Module;
            try {
                if (typeof wasmInstance.cwrap !== 'function') {
                    if (typeof Module !== 'undefined' && typeof Module.cwrap === 'function') wasmInstance = Module;
                }
            } catch (err) { console.error('cwrap lookup error', err); }

            if (!wasmInstance || typeof wasmInstance.cwrap !== 'function') {
                self.postMessage({ ready: false, error: 'cwrap not found on module' });
                return;
            }
            
            wasmInstance.cwrap('initialize_scene', null, [])();

            renderTile = wasmInstance.cwrap('render_tile', 'number', ['number', 'number', 'number', 'number', 'number', 'string', 'number', 'number']);
            freeFunc = wasmInstance.cwrap('free_memory', null, ['number']);
            self.postMessage({ ready: true });
        }

        self.onmessage = async function(e) {
            if (e.data && e.data.wasmBinary) {
                Module = {
                    wasmBinary: e.data.wasmBinary,
                    onRuntimeInitialized: function() {
                        try { onModuleReady(Module); } catch (err) { console.error('onRuntimeInitialized error', err); }
                    }
                };
                try {
                    // This now receives the FULL, correct URL
                    importScripts(e.data.jsUrl);
                } catch (err) {
                    self.postMessage({ ready: false, error: 'importScripts failed for ' + e.data.jsUrl });
                    return;
                }
                try {
                    if (typeof createModule === 'function') {
                        const maybePromise = createModule(Module);
                        if (maybePromise && typeof maybePromise.then === 'function') {
                            maybePromise.then(m => onModuleReady(m)).catch(err => {
                                self.postMessage({ ready: false, error: 'createModule rejected' });
                            });
                        } else { onModuleReady(maybePromise || Module); }
                        return;
                    }
                } catch (err) { console.warn('factory invocation attempt failed', err); }
                return;
            }

            if (!renderTile || !wasmInstance) { return; }

            const { tile, canvasWidth, canvasHeight, samplesPerPixel, maxDepth } = e.data;
            if (!tile) return;
            
            const sceneArg = ""; 
            let pixelDataPtr = 0;
            try {
                pixelDataPtr = renderTile(tile.x, tile.y, tile.size, canvasWidth, canvasHeight, sceneArg, samplesPerPixel, maxDepth);
            } catch (err) { console.error('renderTile call failed', err); return; }

            if (!pixelDataPtr) { console.error('renderTile returned null/0 pointer'); return; }

            const heap = getHeapU8(wasmInstance);
            if (!heap || !heap.buffer) { console.error('HEAPU8 not available after render'); return; }

            const byteLength = tile.size * tile.size * 4;
            const view = new Uint8ClampedArray(heap.buffer, pixelDataPtr, byteLength);
            const copied = new Uint8ClampedArray(byteLength);
            copied.set(view);

            if (freeFunc) { try { freeFunc(pixelDataPtr); } catch (err) { console.warn('free attempt failed', err); } }

            try {
                self.postMessage({ pixelData: copied, tile }, [copied.buffer]);
            } catch (err) {
                self.postMessage({ pixelData: copied.slice(), tile }, []);
            }
        };
    </script>

    <script>
        (function() {
            const startSingleButton = document.getElementById('startSingleButton');
            const startMultiButton = document.getElementById('startMultiButton');
            const threadInput = document.getElementById('threadInput');
            const benchmarkSelector = document.getElementById('benchmarkSelector');
            const canvas = document.getElementById('renderCanvas');
            const ctx = canvas.getContext('2d');
            const singleThreadTimeEl = document.getElementById('singleThreadTime');
            const multiThreadTimeEl = document.getElementById('multiThreadTime');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            let wasmBinaries = {};
            let workerUrl = null;

            // --- CAMBIO CLAVE: Determinar la ruta base correcta ---
            const fullPath = self.location.href;
            const basePath = fullPath.substring(0, fullPath.lastIndexOf('/'));

            threadInput.value = navigator.hardwareConcurrency || 4;
            
            const RENDER_WIDTH = canvas.width, RENDER_HEIGHT = canvas.height;
            const MAX_DEPTH = 25;
            const TILE_SIZE = 64;

            async function prepareWasm(benchmarkName) {
                if (wasmBinaries[benchmarkName]) return;
                progressText.textContent = `Loading ${benchmarkName.toUpperCase()} WASM...`;
                progressBar.style.display = 'block';
                // --- CAMBIO CLAVE: Usar la ruta base para encontrar el archivo .wasm ---
                const wasmResponse = await fetch(`${basePath}/raytracer_${benchmarkName}.wasm`);
                wasmBinaries[benchmarkName] = await wasmResponse.arrayBuffer();

                if (!workerUrl) {
                    const workerScriptContent = document.getElementById('worker-script').textContent;
                    const workerBlob = new Blob([workerScriptContent], { type: 'application/javascript' });
                    workerUrl = URL.createObjectURL(workerBlob);
                }
            }

            async function runBenchmark(numThreads, samplesPerPixel, benchmarkName) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                progressFill.style.width = '0%';
                
                const tiles = [];
                for (let y = 0; y < RENDER_HEIGHT; y += TILE_SIZE) { 
                    for (let x = 0; x < RENDER_WIDTH; x += TILE_SIZE) { 
                        tiles.push({ x, y, size: TILE_SIZE }); 
                    } 
                }
                let workQueue = [...tiles];
                const totalTiles = tiles.length;
                let completedTiles = 0;
                
                progressText.textContent = `Initializing ${numThreads} thread(s)...`;
                const runningWorkers = [];
                for (let i = 0; i < numThreads; i++) {
                    const worker = new Worker(workerUrl);
                    runningWorkers.push({ worker, id: i });
                }

                let initCount = 0;
                // --- CAMBIO CLAVE: Construir la URL completa para el .js y pasarla al worker ---
                const jsUrl = `${basePath}/raytracer_${benchmarkName}.js`;
                const wasmBinary = wasmBinaries[benchmarkName];

                for (const workerObj of runningWorkers) {
                    await new Promise(resolve => {
                        workerObj.worker.onmessage = e => {
                            if (e.data && e.data.ready) {
                                initCount++;
                                progressText.textContent = `Initializing ${initCount}/${numThreads} thread(s)...`;
                                resolve();
                            }
                        };
                        workerObj.worker.postMessage({ wasmBinary: wasmBinary.slice(0), jsUrl: jsUrl });
                    });
                }
                
                progressText.textContent = `Running... (${numThreads} thread/s, ${samplesPerPixel} spp)`;
                
                let startTime;
                let timerStarted = false;

                return new Promise(resolve => {
                    function dispatchWork(workerObj) {
                        if (workQueue.length > 0) {
                            const tile = workQueue.pop();
                            ctx.fillStyle = 'black';
                            ctx.fillRect(tile.x, tile.y, tile.size, tile.size);
                            ctx.font = 'bold 28px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = 'rgba(100, 100, 100, 0.9)';
                            ctx.fillText(workerObj.id, tile.x + tile.size / 2, tile.y + tile.size / 2);

                            const message = { tile, canvasWidth: RENDER_WIDTH, canvasHeight: RENDER_HEIGHT, samplesPerPixel: samplesPerPixel, maxDepth: MAX_DEPTH };
                            workerObj.worker.postMessage(message);
                        }
                    }

                    runningWorkers.forEach(workerObj => {
                        workerObj.worker.onmessage = e => {
                            const { pixelData, tile } = e.data;
                            if (!pixelData) return;
                            
                            if (!timerStarted) {
                                startTime = performance.now();
                                timerStarted = true;
                            }

                            const imageData = new ImageData(new Uint8ClampedArray(pixelData), tile.size, tile.size);
                            ctx.putImageData(imageData, tile.x, tile.y);
                            
                            completedTiles++;
                            const progressPercentage = (completedTiles / totalTiles) * 100;
                            progressFill.style.width = `${progressPercentage}%`;
                            progressText.textContent = `${Math.round(progressPercentage)}%`;

                            if (completedTiles === totalTiles) {
                                const endTime = performance.now();
                                const totalTime = (endTime - startTime) / 1000;
                                runningWorkers.forEach(w => w.worker.terminate());
                                resolve(totalTime);
                            } else {
                                dispatchWork(workerObj);
                            }
                        };
                        dispatchWork(workerObj);
                    });
                });
            }

            async function startBenchmark(numThreads, targetTimeEl) {
                startSingleButton.disabled = true;
                startMultiButton.disabled = true;
                targetTimeEl.textContent = '...';

                const samplesPerPixel = parseInt(benchmarkSelector.value, 10);
                let benchmarkName = 'medium';
                if (samplesPerPixel === 64) benchmarkName = 'light';
                if (samplesPerPixel === 512) benchmarkName = 'heavy';
                
                await prepareWasm(benchmarkName);
                const time = await runBenchmark(numThreads, samplesPerPixel, benchmarkName);
                targetTimeEl.textContent = `${time.toFixed(3)}s`;
                progressText.textContent = 'Done!';
                startSingleButton.disabled = false;
                startMultiButton.disabled = false;
            }

            startSingleButton.addEventListener('click', () => {
                startBenchmark(1, singleThreadTimeEl);
            });

            startMultiButton.addEventListener('click', () => {
                let numThreads = parseInt(threadInput.value, 10);
                if (isNaN(numThreads) || numThreads <= 0) {
                    numThreads = navigator.hardwareConcurrency || 4;
                    threadInput.value = numThreads;
                }
                startBenchmark(numThreads, multiThreadTimeEl);
            });
        })();
    </script>
</body>
</html>
