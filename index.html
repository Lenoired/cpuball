<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Monolith Pathtracer</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #121212; color: #e0e0e0; margin: 0; padding: 1rem; box-sizing: border-box; -webkit-user-select: none; -ms-user-select: none; user-select: none; }
        input, textarea, select { -webkit-user-select: text; -ms-user-select: text; user-select: text; }
        #container { text-align: center; background-color: #1e1e1e; padding: 2rem; border-radius: 12px; width: 100%; max-width: 1100px; }
        h1 { color: #ffffff; margin-top: 0; font-size: 2.5em; }
        p { max-width: 650px; margin: 0.5rem auto 1rem auto; color: #aaa; }
        canvas { background-color: #000; border-radius: 8px; margin-top: 1rem; width: 100%; height: auto; border: 1px solid #333; }
        #controls { margin: 1.5rem 0; }
        .input-group { display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 1rem; flex-wrap: wrap; }
        .thread-info-text { color: #888; opacity: 0.7; font-size: 0.9em; font-style: italic; margin-right: 15px; }
        .input-group label { font-size: 1.1em; }
        #threadInput, #benchmarkSelector, #customSamplesInput, #tileSizeInput, #maxDepthInput, #sceneSelector, #resolutionInput { padding: 10px; font-size: 1.1em; border-radius: 8px; border: 1px solid #333; background-color: #2a2a2a; color: #e0e0e0; }
        #threadInput, #customSamplesInput, #tileSizeInput, #maxDepthInput { width: 80px; text-align: center; }
        #resolutionInput { width: 120px; text-align: center; }
        #custom-samples-group { display: none; }
        .button-group { display: flex; justify-content: center; gap: 1rem; margin-top: 1rem; }
        .benchmark-button { padding: 14px 28px; font-size: 1.1em; font-weight: bold; cursor: pointer; border: none; border-radius: 8px; transition: background-color 0.2s ease; }
        .benchmark-button:disabled { background-color: #555; cursor: not-allowed; }
        .start-button { background-color: #d93025; color: white; }
        .start-button:not(:disabled):hover { background-color: #e84c4c; }
        #stopButton { background-color: #6c757d; color: white; }
        #stopButton:not(:disabled) { background-color: #28a745; }
        #stopButton:not(:disabled):hover { background-color: #218838; }
        #results { margin-top: 1rem; background-color: #2a2a2a; padding: 1rem 1.5rem; border-radius: 8px; display: inline-block; min-width: 350px; }
        #results p { margin: 0.5rem 0; font-size: 1.2em; text-align: left; color: #fff; }
        #results strong { display: inline-block; width: 200px; }
        #reset-container { margin-top: 1.5rem; }
        #resetButton { background-color: #007bff; color: white; font-size: 1em; padding: 10px 20px; }
        #resetButton:hover { background-color: #0069d9; }
        #progressBar { width: 100%; height: 28px; background-color: #333; border-radius: 14px; margin-top: 1.5rem; overflow: hidden; display: none; position: relative; }
        #progressFill { width: 0%; height: 100%; background-color: #d93025; transition: width 0.1s linear; }
        #progressText { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; text-shadow: 1px 1px 2px black; }
        #disclaimer { margin-top: 1rem; color: #888; opacity: 0.7; font-size: 0.9em; font-style: italic; }
        .control-item { margin-top: 1rem; }
    </style>
</head>
<body>
    <div id="container">
        <h1>Monolith Pathtracer</h1>
        <p>A CPU path tracing utility.</p>
        <canvas id="renderCanvas" width="1600" height="900"></canvas>
        <div id="progressBar"> <div id="progressFill"></div> <div id="progressText"></div> </div>
        <div id="controls">
            <div class="input-group">
                <!-- === NEW SCENE SELECTOR === -->
                <label for="sceneSelector">Scene:</label>
                <select id="sceneSelector">
				     <option value="gauss" selected>Caustic Hell (extremely demanding, needs >256 ray bounces)</option>
				     <option value="v3">Spheres (enhanced, realistic)</option>
				    <option value="v2">Spheres (v2, unrealistic)</option>
                    <option value="old">Spheres (v1, old, ugly)</option>
                 
                </select>

                <label for="benchmarkSelector" style="margin-left: 20px;">Benchmark Preset:</label>
                <select id="benchmarkSelector">
                    <option value="16">Ultra Light (16 Samples)</option>
                    <option value="64">Light (64 Samples)</option>
                    <option value="256" selected>Medium (256 Samples)</option>
                    <option value="512">Heavy (512 Samples)</option>
                    <option value="1024">Extreme (1024 Samples)</option>
                    <option value="custom">Custom</option>
                </select>
                <div id="custom-samples-group" class="input-group" style="margin-bottom: 0;">
                    <label for="customSamplesInput">Samples:</label>
                    <input type="number" id="customSamplesInput" value="128" min="1">
                </div>
            </div>
            <div class="input-group">
                <span class="thread-info-text">Wrong thread count? Change it manually.</span>
                <label for="threadInput">Threads:</label>
                <input type="number" id="threadInput" title="Enter the number of threads for the multi-threaded test." min="1">
            </div>
             <div class="input-group">
			       <label for="resolutionInput" style="margin-left: 20px;">Resolution:</label>
                <input type="text" id="resolutionInput" placeholder="1600x900">
				
                <label for="tileSizeInput">Render Tile Size:</label>
                <input type="number" id="tileSizeInput" title="Size of the rendering chunks in pixels." value="64" min="16" step="16">
                
    
                <label for="maxDepthInput" style="margin-left: 20px;">Max Ray Bounces:</label>
                <input type="number" id="maxDepthInput" title="Maximum number of ray bounces." value="512" min="1">
            </div>
            <div class="button-group">
                <button id="startSingleButton" class="benchmark-button start-button">Start Single-Threaded</button>
                <button id="startMultiButton" class="benchmark-button start-button">Start Multi-Threaded</button>
                <button id="stopButton" class="benchmark-button" disabled>Stop</button>
            </div>
            <div class="control-item">
              <label for="denoiser-toggle">Denoiser:</label>
              <input type="checkbox" id="denoiser-toggle">
            </div>
        </div>
        <div id="results">
            <p><strong>Single-thread time:</strong> <span id="singleThreadTime">-</span></p>
            <p><strong>Multi-thread time:</strong> <span id="multiThreadTime">-</span></p>
        </div>
        <div id="reset-container"> <button id="resetButton" class="benchmark-button">Reset to default</button> </div>
        <p id="disclaimer">Please note: Scene initialization may take a few moments, particularly on tests with a high sample count.</p>
    </div>

    <script id="worker-script" type="text/worker">
        var Module = null; var wasmInstance = null; var renderTile = null; var freeFunc = null; function getHeapU8(mod) { if (!mod) { if (typeof HEAPU8 !== 'undefined') return HEAPU8; return null; } if (mod.HEAPU8) return mod.HEAPU8; if (mod.asm && mod.asm.HEAPU8) return mod.asm.HEAPU8; if (typeof HEAPU8 !== 'undefined') return HEAPU8; return null; }
        function onModuleReady(m) { wasmInstance = m || Module; try { if (typeof wasmInstance.cwrap !== 'function') { if (typeof Module !== 'undefined' && typeof Module.cwrap === 'function') wasmInstance = Module; } } catch (err) { console.error('cwrap lookup error', err); } if (!wasmInstance || typeof wasmInstance.cwrap !== 'function') { self.postMessage({ ready: false, error: 'cwrap not found on module' }); return; }
        renderTile = wasmInstance.cwrap('render_tile', 'number', ['number', 'number', 'number', 'number', 'number', 'string', 'number', 'number', 'boolean']);
        freeFunc = wasmInstance.cwrap('free_memory', null, ['number']); self.postMessage({ ready: true }); }
        self.onmessage = async function(e) { if (e.data && e.data.wasmBinary) { Module = { wasmBinary: e.data.wasmBinary, onRuntimeInitialized: function() { try { onModuleReady(Module); } catch (err) { console.error('onRuntimeInitialized error', err); } } }; try { importScripts(e.data.jsUrl); } catch (err) { self.postMessage({ ready: false, error: 'importScripts failed for ' + e.data.jsUrl }); return; } try { if (typeof createModule === 'function') { const maybePromise = createModule(Module); if (maybePromise && typeof maybePromise.then === 'function') { maybePromise.then(m => onModuleReady(m)).catch(err => { self.postMessage({ ready: false, error: 'createModule rejected' }); }); } else { onModuleReady(maybePromise || Module); } return; } } catch (err) { console.warn('factory invocation attempt failed', err); } return; } if (!renderTile || !wasmInstance) { return; }
        const { tile, canvasWidth, canvasHeight, samplesPerPixel, maxDepth, useDenoiser } = e.data;
        if (!tile) return; const sceneArg = ""; let pixelDataPtr = 0; try {
        pixelDataPtr = renderTile(tile.x, tile.y, tile.size, canvasWidth, canvasHeight, sceneArg, samplesPerPixel, maxDepth, useDenoiser);
        } catch (err) { console.error('renderTile call failed', err); return; } if (!pixelDataPtr) { console.error('renderTile returned null/0 pointer'); return; } const heap = getHeapU8(wasmInstance); if (!heap || !heap.buffer) { console.error('HEAPU8 not available after render'); return; } const byteLength = tile.size * tile.size * 4; const view = new Uint8ClampedArray(heap.buffer, pixelDataPtr, byteLength); const copied = new Uint8ClampedArray(byteLength); copied.set(view); if (freeFunc) { try { freeFunc(pixelDataPtr); } catch (err) { console.warn('free attempt failed', err); } } try { self.postMessage({ pixelData: copied, tile }, [copied.buffer]); } catch (err) { self.postMessage({ pixelData: copied.slice(), tile }, []); } };
    </script>

    <script>
        (function() {
            const startSingleButton = document.getElementById('startSingleButton');
            const startMultiButton = document.getElementById('startMultiButton');
            const stopButton = document.getElementById('stopButton');
            const resetButton = document.getElementById('resetButton');
            const threadInput = document.getElementById('threadInput');
            const benchmarkSelector = document.getElementById('benchmarkSelector');
            const canvas = document.getElementById('renderCanvas');
            const ctx = canvas.getContext('2d');
            const singleThreadTimeEl = document.getElementById('singleThreadTime');
            const multiThreadTimeEl = document.getElementById('multiThreadTime');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const customSamplesGroup = document.getElementById('custom-samples-group');
            const customSamplesInput = document.getElementById('customSamplesInput');
            const tileSizeInput = document.getElementById('tileSizeInput');
            const maxDepthInput = document.getElementById('maxDepthInput');
            const resolutionInput = document.getElementById('resolutionInput'); // Get resolution input
            const sceneSelector = document.getElementById('sceneSelector');
            const denoiserToggle = document.getElementById('denoiser-toggle');

            let wasmBinaries = {}; let workerUrl = null; let activeWorkers = []; let isBenchmarkRunning = false;
            const fullPath = self.location.href; const basePath = fullPath.substring(0, fullPath.lastIndexOf('/'));
            threadInput.value = navigator.hardwareConcurrency || 4;
            
            // Use variables instead of constants for dynamic resolution
            let renderWidth = canvas.width, renderHeight = canvas.height;

            function checkCustomPreset() { if (benchmarkSelector.value === 'custom') { customSamplesGroup.style.display = 'flex'; } else { customSamplesGroup.style.display = 'none'; } }
            checkCustomPreset();
            benchmarkSelector.addEventListener('change', checkCustomPreset);

            function updateUIForScene() {
                const selectedScene = sceneSelector.value;
                const supportsDenoiser = (selectedScene === 'v2' || selectedScene === 'gauss' || selectedScene === 'v3');
                denoiserToggle.disabled = !supportsDenoiser;
                if (!supportsDenoiser) {
                    denoiserToggle.checked = false;
                }
            }
            sceneSelector.addEventListener('change', updateUIForScene);
            updateUIForScene(); 

            // Function to parse resolution input and update canvas
            function parseAndUpdateResolution() {
                const defaultWidth = 1600;
                const defaultHeight = 900;
                const resValue = resolutionInput.value.trim();

                if (!resValue) { // If empty, use default
                    renderWidth = defaultWidth;
                    renderHeight = defaultHeight;
                } else {
                    const parts = resValue.toLowerCase().split('x');
                    if (parts.length !== 2) {
                        renderWidth = defaultWidth;
                        renderHeight = defaultHeight;
                        resolutionInput.value = `${defaultWidth}x${defaultHeight}`; // Show user the fallback
                        console.warn("Invalid resolution format. Falling back to 1600x900.");
                    } else {
                        const width = parseInt(parts[0], 10);
                        const height = parseInt(parts[1], 10);

                        if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
                            renderWidth = defaultWidth;
                            renderHeight = defaultHeight;
                            resolutionInput.value = `${defaultWidth}x${defaultHeight}`;
                            console.warn("Invalid resolution numbers. Falling back to 1600x900.");
                        } else {
                            renderWidth = width;
                            renderHeight = height;
                        }
                    }
                }
                // Update canvas element's actual size
                canvas.width = renderWidth;
                canvas.height = renderHeight;
            }

            async function prepareWasm(benchmarkName) {
                if (wasmBinaries[benchmarkName]) return;
                try {
                    const wasmResponse = await fetch(`${basePath}/raytracer_${benchmarkName}.wasm`);
                    if (!wasmResponse.ok) throw new Error(`Failed to fetch WASM file: ${wasmResponse.statusText}`);
                    wasmBinaries[benchmarkName] = await wasmResponse.arrayBuffer();
                    if (!workerUrl) {
                        const workerScriptContent = document.getElementById('worker-script').textContent;
                        const workerBlob = new Blob([workerScriptContent], { type: 'application/javascript' });
                        workerUrl = URL.createObjectURL(workerBlob);
                    }
                } catch (error) {
                    console.error("WASM Preparation Error:", error);
                    progressText.textContent = `Error: Could not load scene files.`;
                    throw error;
                }
            }
            
            async function runBenchmark(numThreads, samplesPerPixel, TILE_SIZE, MAX_DEPTH, benchmarkName, useDenoiser) {
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height); progressFill.style.width = '0%';
                const tiles = [];
                // Use the updated renderWidth and renderHeight variables
                for (let y = 0; y < renderHeight; y += TILE_SIZE) { 
                    for (let x = 0; x < renderWidth; x += TILE_SIZE) { 
                        tiles.push({ x, y, size: TILE_SIZE }); 
                    } 
                }
                let workQueue = [...tiles]; const totalTiles = tiles.length; let completedTiles = 0;
                progressText.textContent = `Creating ${numThreads} thread(s)...`;
                let startTime; let timerStarted = false; let hasFailed = false;

                return new Promise((resolve, reject) => {
                    let initializedWorkers = 0;
                    const cleanupAndFail = (errorMessage) => { if (hasFailed) return; hasFailed = true; isBenchmarkRunning = false; console.error(errorMessage); progressText.textContent = `Error: ${errorMessage}`; activeWorkers.forEach(w => { if (w && w.worker) w.worker.terminate(); }); activeWorkers = []; reject(new Error(errorMessage)); };
                    const onWorkerMessage = (workerObj, e) => {
                        if (!isBenchmarkRunning || hasFailed) return;
                        if (e.data && e.data.error) { cleanupAndFail(`Worker #${workerObj.id} failed: ${e.data.error}`); return; }
                        if (e.data && e.data.ready && !workerObj.isReady) {
                            workerObj.isReady = true; initializedWorkers++;
                            progressText.textContent = `Initializing ${initializedWorkers}/${numThreads} thread(s)...`;
                            if (initializedWorkers === numThreads) {
                                progressText.textContent = `Initializing scene... (${numThreads} thread/s, ${samplesPerPixel} spp)`;
                                activeWorkers.forEach(w => dispatchWork(w));
                            } else { createNextWorker(); }
                            return;
                        }
                        if (e.data && e.data.pixelData) {
                            if (!timerStarted) { startTime = performance.now(); timerStarted = true; }
                            const { pixelData, tile } = e.data; const imageData = new ImageData(new Uint8ClampedArray(pixelData), tile.size, tile.size); ctx.putImageData(imageData, tile.x, tile.y);
                            completedTiles++; const progressPercentage = (completedTiles / totalTiles) * 100;
                            progressFill.style.width = `${progressPercentage}%`; progressText.textContent = `${Math.round(progressPercentage)}%`;
                            if (completedTiles === totalTiles) {
                                const totalTime = (performance.now() - startTime) / 1000;
                                activeWorkers.forEach(w => w.worker.terminate()); activeWorkers = [];
                                resolve({ time: totalTime });
                            } else { dispatchWork(workerObj); }
                        }
                    };
                    function dispatchWork(workerObj) { if (workQueue.length > 0) { const tile = workQueue.pop(); ctx.fillStyle = 'black'; ctx.fillRect(tile.x, tile.y, tile.size, tile.size); ctx.font = 'bold 28px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = 'rgba(100, 100, 100, 0.9)'; ctx.fillText(workerObj.id, tile.x + tile.size / 2, tile.y + tile.size / 2);
                    // Pass the updated renderWidth and renderHeight to the worker
                    const message = { tile, canvasWidth: renderWidth, canvasHeight: renderHeight, samplesPerPixel, maxDepth: MAX_DEPTH, useDenoiser };
                    workerObj.worker.postMessage(message); } }
                    
                    const jsUrl = `${basePath}/raytracer_${benchmarkName}.js`;
                    const wasmBinary = wasmBinaries[benchmarkName];
                    let workerCreationIndex = 0;
                    function createNextWorker() { if (workerCreationIndex >= numThreads || hasFailed) return; const i = workerCreationIndex++; try { const worker = new Worker(workerUrl); const workerObj = { worker, id: i, isReady: false }; worker.onmessage = (e) => onWorkerMessage(workerObj, e); worker.onerror = (e) => cleanupAndFail(`An unexpected error in Worker #${i}: ${e.message}`); activeWorkers.push(workerObj); worker.postMessage({ wasmBinary: wasmBinary.slice(0), jsUrl: jsUrl }); } catch (error) { cleanupAndFail(`Failed to create Worker #${i}. Your browser may have run out of memory.`); } }
                    createNextWorker();
                });
            }

            async function startBenchmark(numThreads, targetTimeEl) {
                isBenchmarkRunning = true;
                startSingleButton.disabled = true; startMultiButton.disabled = true; stopButton.disabled = false;
                targetTimeEl.textContent = '...'; progressBar.style.display = 'block'; progressText.textContent = '';
                
                // Parse and set the resolution right before the benchmark starts
                parseAndUpdateResolution();

                try {
                    let samplesPerPixel = parseInt(benchmarkSelector.value === 'custom' ? customSamplesInput.value : benchmarkSelector.value, 10);
                    if (isNaN(samplesPerPixel) || samplesPerPixel <= 0) throw new Error("Please enter a valid number of samples.");
                    const TILE_SIZE = parseInt(tileSizeInput.value, 10) || 64;
                    const MAX_DEPTH = parseInt(maxDepthInput.value, 10) || 512;
                    const benchmarkName = sceneSelector.value;
                    const useDenoiser = denoiserToggle.checked;
                    
                    await prepareWasm(benchmarkName);
                    const result = await runBenchmark(numThreads, samplesPerPixel, TILE_SIZE, MAX_DEPTH, benchmarkName, useDenoiser);
                    targetTimeEl.textContent = `${result.time.toFixed(3)}s`;
                    progressText.textContent = 'Done!';
                } catch (error) {
                   
                } finally {
                    if (isBenchmarkRunning) {
                        isBenchmarkRunning = false;
                        startSingleButton.disabled = false; startMultiButton.disabled = false; stopButton.disabled = true;
                    }
                }
            }

            stopButton.addEventListener('click', () => {
                if (!isBenchmarkRunning) return;
                console.log("Stopping benchmark..."); isBenchmarkRunning = false;
                activeWorkers.forEach(w => w.worker.terminate()); activeWorkers = [];
                progressText.textContent = 'Benchmark Stopped.';
                singleThreadTimeEl.textContent = '-'; multiThreadTimeEl.textContent = '-';
                startSingleButton.disabled = false; startMultiButton.disabled = false; stopButton.disabled = true;
            });
            
            resetButton.addEventListener('click', () => {
                console.log("Resetting settings to default.");
                sceneSelector.value = "gauss";
                benchmarkSelector.value = "256"; customSamplesInput.value = "128";
                threadInput.value = navigator.hardwareConcurrency || 4;
                tileSizeInput.value = "64"; maxDepthInput.value = "512";
                resolutionInput.value = ""; // Reset resolution input
                denoiserToggle.checked = false;
                checkCustomPreset();
                updateUIForScene();
            });

            startSingleButton.addEventListener('click', () => { startBenchmark(1, singleThreadTimeEl); });
            startMultiButton.addEventListener('click', () => { let numThreads = parseInt(threadInput.value, 10); if (isNaN(numThreads) || numThreads <= 0) { numThreads = navigator.hardwareConcurrency || 4; threadInput.value = numThreads; } startBenchmark(numThreads, multiThreadTimeEl); });

        })();
    </script>
</body>
</html>
